// app/lib/workflow/WorkflowManager.ts

import type { WebContainer } from '@webcontainer/api';
import type { BoltShell } from '~/utils/shell';
import type { Agent, Task, WorkflowState, AgentInput, AgentOutput } from './types';
import { LLMManager } from '~/lib/modules/llm/manager';
import { ActionRunner } from '~/lib/runtime/action-runner';
import type { ActionCallbackData, FileAction, ShellAction, BoltAction } from '~/types/actions'; // Adjusted path

/**
 * Manages the lifecycle and execution of a workflow.
 */
export class WorkflowManager {
  private workflowState: WorkflowState;
  private agents: Map<string, Agent> = new Map();
  private actionRunner?: ActionRunner;

  /**
   * Generates a unique ID for tasks or workflows.
   * @returns A unique string ID.
   */
  private generateId(): string {
    // Use a more robust unique ID generator if available, e.g. crypto.randomUUID if in Node 14+ or browser
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 11);
  }

  /**
   * Creates an instance of WorkflowManager.
   * @param initialUserInput The initial input from the user that starts the workflow.
   * @param llmManager An instance of LLMManager.
   * @param webcontainerPromise Optional promise for WebContainer initialization.
   * @param getShellTerminal Optional function to get BoltShell instance.
   */
  constructor(
    private initialUserInput: string,
    private llmManager: LLMManager, // Keep for future use with agents
    webcontainerPromise?: Promise<WebContainer>,
    getShellTerminal?: () => BoltShell,
  ) {
    this.workflowState = {
      workflowId: this.generateId(),
      originalUserInput: this.initialUserInput,
      tasks: [],
      currentTaskIndex: 0,
      sharedContext: {},
      status: 'pending',
    };

    if (webcontainerPromise && getShellTerminal) {
      this.actionRunner = new ActionRunner(webcontainerPromise, getShellTerminal);
      // console.log('ActionRunner initialized in WorkflowManager.');
      // ActionRunner onAlert handlers can be set here if needed, e.g.:
      // this.actionRunner.onAlert = (message, type) => {
      //  console.log(`ActionRunner Alert (${type}): ${message}`);
      // };
    }
  }

  /**
   * Registers an agent that can be used in the workflow.
   * @param agent The agent to register.
   */
  public registerAgent(agent: Agent): void {
    this.agents.set(agent.name, agent);
    console.log(`Agent registered: ${agent.name}`);
  }

  /**
   * Plans the workflow by creating a list of tasks.
   * (Currently a placeholder with hardcoded tasks).
   * @returns A promise that resolves when planning is complete.
   */
  public async plan(): Promise<void> {
    console.log("Planning workflow using PlanningAgent...");
    this.workflowState.status = 'running'; // Mark as running during planning

    const planningAgent = this.agents.get('PlanningAgent');
    if (!planningAgent) {
      this.workflowState.status = 'failed';
      this.workflowState.tasks = []; // Ensure tasks is empty
      console.error("PlanningAgent not registered. Cannot plan workflow.");
      // Optionally, add an error to a dedicated field in workflowState if that's desired
      // this.workflowState.error = "PlanningAgent not registered.";
      return;
    }

    const initialPlanningTask: Task = {
      id: this.generateId(),
      agentName: 'PlanningAgent',
      input: { request: this.initialUserInput }, // PlanningAgent expects 'request' in its input
      status: 'running', // Mark as running
      createdAt: new Date(),
      updatedAt: new Date(),
      startedAt: new Date(),
    };

    try {
      const output: AgentOutput = await planningAgent.execute(initialPlanningTask, this.workflowState);
      initialPlanningTask.updatedAt = new Date();
      initialPlanningTask.completedAt = new Date();

      if (output.status === 'success' && output.plannedTasks && output.plannedTasks.length > 0) {
        this.workflowState.tasks = output.plannedTasks;
        initialPlanningTask.status = 'completed';
        if (output.sharedContextUpdates) {
          this.workflowState.sharedContext = {
            ...this.workflowState.sharedContext,
            ...output.sharedContextUpdates,
          };
          console.log("Workflow sharedContext updated by PlanningAgent:", output.sharedContextUpdates);
        }
        this.workflowState.status = 'pending'; // Ready to be executed, or could be 'planned'
        console.log(`Planning complete. ${this.workflowState.tasks.length} tasks generated by PlanningAgent.`);
        console.log("Planned tasks: ", this.workflowState.tasks.map(t => ({id: t.id, agentName: t.agentName, input: t.input })));
      } else {
        initialPlanningTask.status = 'failed';
        initialPlanningTask.error = output.error || "PlanningAgent failed to produce tasks.";
        this.workflowState.status = 'failed';
        this.workflowState.tasks = []; // Ensure tasks is empty on failure
        console.error("PlanningAgent execution failed or returned no tasks:", output.error);
        // this.workflowState.error = output.error || "PlanningAgent failed to produce tasks.";
      }
    } catch (error: any) {
      initialPlanningTask.status = 'failed';
      initialPlanningTask.error = error.message;
      initialPlanningTask.updatedAt = new Date();
      initialPlanningTask.completedAt = new Date();
      this.workflowState.status = 'failed';
      this.workflowState.tasks = [];
      console.error("Error during PlanningAgent execution:", error);
      // this.workflowState.error = error.message;
    }
    // It might be useful to store the planning task itself in the workflow state for audit/logging
    // For example: this.workflowState.planningTask = initialPlanningTask;
  }

  /**
   * Executes the workflow task by task.
   * @returns A promise that resolves when the workflow execution is finished (completed or failed).
   */
  public async executeWorkflow(): Promise<void> {
    if (this.workflowState.tasks.length === 0) {
      console.warn("No tasks to execute. Did you call plan() first?");
      this.workflowState.status = 'completed'; // Or 'failed' if no tasks is an error
      return Promise.resolve();
    }

    this.workflowState.status = 'running';
    console.log(`Executing workflow: ${this.workflowState.workflowId}`);

    for (let i = this.workflowState.currentTaskIndex; i < this.workflowState.tasks.length; i++) {
      const task = this.workflowState.tasks[i];
      console.log(`Executing task: ${task.id} - ${task.agentName}`);

      task.status = 'running';
      task.startedAt = new Date();
      task.updatedAt = new Date();

      const agent = this.agents.get(task.agentName);

      if (!agent) {
        task.status = 'failed';
        task.error = `Agent not found: ${task.agentName}`;
        task.completedAt = new Date();
        task.updatedAt = new Date();
        this.workflowState.status = 'failed';
        console.error(task.error);
        break; // Stop workflow execution
      }

      try {
        console.log(`Calling agent: ${agent.name} for task ${task.id}`);
        const output: AgentOutput = await agent.execute(task, this.workflowState);
        task.output = output; // Store the full output
        task.updatedAt = new Date();

        // Merge shared context updates from the agent
        if (output.sharedContextUpdates) {
          this.workflowState.sharedContext = {
            ...this.workflowState.sharedContext,
            ...output.sharedContextUpdates,
          };
          console.log(`Workflow sharedContext updated by ${agent.name} for task ${task.id}:`, output.sharedContextUpdates);
        }

        // Handle agent execution status
        if (output.status === 'failure') {
          task.status = 'failed';
          task.error = output.error || `Agent ${agent.name} reported failure without a specific error message.`;
          this.workflowState.status = 'failed';
          console.error(`Task ${task.id} (agent: ${agent.name}) failed: ${task.error}`);
          break; // Stop workflow on task failure
        }

        // Process actionString if present and ActionRunner is available
        if (output.actionString && this.actionRunner) {
          console.log(`WorkflowManager: Executing action string for task ${task.id}: ${output.actionString.substring(0, 100)}...`);
          const actionData = this.parseBoltActionString(output.actionString, task.id);

          if (actionData) {
            this.actionRunner.addAction(actionData);
            await this.actionRunner.runAction(actionData);
            const executedActionState = this.actionRunner.actions.get()[actionData.actionId];

            if (executedActionState?.status === 'failed') {
              task.status = 'failed';
              task.error = executedActionState.error || 'ActionRunner failed to execute action.';
              this.workflowState.status = 'failed';
              console.error(`Task ${task.id} (agent: ${agent.name}) action failed: ${task.error}`);
              break; // Stop workflow on action failure
            } else if (executedActionState?.status === 'complete') {
              task.status = 'completed';
              console.log(`Task ${task.id} (agent: ${agent.name}) action executed successfully by ActionRunner.`);
            } else {
              // Should not happen if runAction is awaited and handles its states properly
              task.status = 'failed';
              task.error = `Action did not complete as expected: ${executedActionState?.status}`;
              this.workflowState.status = 'failed';
              console.error(`Task ${task.id} (agent: ${agent.name}) action status unexpected: ${executedActionState?.status}`);
              break; // Stop workflow
            }
          } else {
            task.status = 'failed';
            task.error = 'Failed to parse actionString from agent.';
            this.workflowState.status = 'failed';
            console.error(`Task ${task.id} (agent: ${agent.name}) failed: ${task.error}`);
            break; // Stop workflow
          }
        } else if (output.actionString && !this.actionRunner) {
            task.status = 'failed';
            task.error = `Agent ${agent.name} produced an actionString but ActionRunner is not available.`;
            this.workflowState.status = 'failed';
            console.error(`Task ${task.id} (agent: ${agent.name}) failed: ${task.error}`);
            break; // Stop workflow
        } else {
          // No actionString, or ActionRunner not available.
          // If output.status was 'success' (implicitly or explicitly), task is considered completed by the agent itself.
          task.status = 'completed';
          console.log(`Task ${task.id} (agent: ${agent.name}) completed by agent logic (no action string or ActionRunner not used).`);
        }
        task.completedAt = new Date();
        task.updatedAt = new Date();

      } catch (error: any) { // Catch errors from agent.execute() itself
        task.status = 'failed';
        task.error = error.message || `Agent ${agent.name} execution threw an unhandled error.`;
        task.completedAt = new Date(); // Mark completion time even on failure
        task.updatedAt = new Date();
        this.workflowState.status = 'failed';
        console.error(`Error executing task ${task.id} with agent ${agent.name}:`, error);
        break; // Stop workflow execution
      }

      this.workflowState.currentTaskIndex = i + 1;
    }

    if (this.workflowState.status !== 'failed') {
      // Check if all tasks are actually completed
      const allTasksCompleted = this.workflowState.tasks.every(t => t.status === 'completed');
      if (allTasksCompleted) {
        this.workflowState.status = 'completed';
        console.log(`Workflow ${this.workflowState.workflowId} completed successfully.`);
      } else {
        // This case might happen if the loop finishes but not all tasks are 'completed'
        // (e.g. if a task was skipped, which is not current logic, but for robustness)
        // Or if a task failed and broke the loop, status would already be 'failed'.
        if (this.workflowState.status !== 'failed') { // if not already set to failed by a task
            this.workflowState.status = 'failed'; // Or some other status like 'incomplete'
            console.log(`Workflow ${this.workflowState.workflowId} finished with incomplete tasks.`);
        }
      }
    } else {
      console.log(`Workflow ${this.workflowState.workflowId} failed.`);
    }

    return Promise.resolve();
  }

  /**
   * Gets the current state of the workflow.
   * @returns The current workflow state.
   */
  public getWorkflowState(): WorkflowState {
    return this.workflowState;
  }

  /**
   * Parses a <boltAction> string into an ActionCallbackData object.
   * @param actionString The XML-like string from an agent.
   * @param taskId The ID of the task requesting the action.
   * @returns ActionCallbackData if parsing is successful, null otherwise.
   */
  private parseBoltActionString(actionString: string, taskId: string): ActionCallbackData | null {
    const typeMatch = actionString.match(/type="([^"]+)"/);
    const actionType = typeMatch ? typeMatch[1] : null;

    if (!actionType) {
      console.error("parseBoltActionString: Could not parse action type from string:", actionString);
      return null;
    }

    // Generate a unique ID for this specific action instance
    const actionId = `${taskId}_action_${this.generateId()}`;

    if (actionType === 'file') {
      const filePathMatch = actionString.match(/filePath="([^"]+)"/);
      // Regex for content, attempting to capture everything between content="..."
      // It handles escaped quotes inside the content if the source XML escapes them (e.g., &quot;)
      // and basic newlines. For truly complex XML/CDATA, a proper parser is better.
      const contentMatch = actionString.match(/content="((?:.|\r|\n)*?)"(?:\s|>|$)/);
      
      if (filePathMatch && contentMatch) {
        // Basic unescaping for content that might have been escaped by the agent
        const unescapedContent = contentMatch[1]
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&apos;/g, "'");

        return {
          actionId,
          action: {
            type: 'file',
            filePath: filePathMatch[1],
            content: unescapedContent, // Use unescaped content
            changeSource: 'agent', // Or another source as appropriate
          } as FileAction,
        };
      } else {
        console.error("parseBoltActionString: FileAction missing filePath or content:", actionString);
      }
    } else if (actionType === 'shell') {
      const contentMatch = actionString.match(/content="((?:.|\r|\n)*?)"(?:\s|>|$)/);
      if (contentMatch) {
         const unescapedContent = contentMatch[1]
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&apos;/g, "'");
        return {
          actionId,
          action: {
            type: 'shell',
            content: unescapedContent, // Use unescaped content
          } as ShellAction,
        };
      } else {
        console.error("parseBoltActionString: ShellAction missing content:", actionString);
      }
    } else {
        console.error(`parseBoltActionString: Unsupported action type "${actionType}" from string:`, actionString);
    }
    return null;
  }
}

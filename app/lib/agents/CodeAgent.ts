// app/lib/agents/CodeAgent.ts

import type { Agent, Task, WorkflowState, AgentInput, AgentOutput } from '../workflow/types';
import type { LLMManager } from '~/lib/modules/llm/manager';
import { generateText } from 'ai'; // Import generateText

/**
 * CodeAgent handles writing or modifying code within files.
 * It can either write provided code directly or use an LLM to generate code based on a description.
 */
export class CodeAgent implements Agent {
  public readonly name = "CodeAgent";
  public readonly description = "Handles writing or modifying code within files, potentially using an LLM for code generation.";

  /**
   * Creates an instance of CodeAgent.
   * @param llmManager LLMManager for code generation capabilities.
   */
  constructor(private llmManager: LLMManager) {}

  /**
   * Executes the code writing/modification task.
   * @param task The task containing input for the code operation.
   * @param workflowState The current state of the workflow.
   * @returns A promise that resolves to an AgentOutput containing the boltAction string or an error.
   */
  public async execute(task: Task, workflowState: WorkflowState): Promise<AgentOutput> {
    const { filePath, codeContent, codeDescription, language } = task.input as {
      filePath?: string;
      codeContent?: string;
      codeDescription?: string;
      language?: string; // For future use with LLM
    };

    if (!filePath) {
      console.error("CodeAgent: Missing filePath in task input.");
      return { error: "Missing filePath for CodeAgent", status: "failure" };
    }

    let actionString: string;
    let message: string | undefined;

    if (typeof codeContent === 'string') {
      console.log(`CodeAgent: Writing provided code to file '${filePath}'.`);
      actionString = `<boltAction type="file" filePath="${this.escapeXml(filePath)}" content="${this.escapeXml(codeContent)}"></boltAction>`;
      return { actionString, status: "success", message: "Used provided code content." };

    } else if (typeof codeDescription === 'string') {
      if (!this.llmManager) {
        console.warn("CodeAgent: LLMManager not available, falling back to placeholder for code generation.");
        const placeholderCode = `// TODO: LLMManager not available. Implement code for: ${this.escapeXml(codeDescription)}
// Language: ${language || 'unknown'}`;
        actionString = `<boltAction type="file" filePath="${this.escapeXml(filePath)}" content="${this.escapeXml(placeholderCode)}"></boltAction>`;
        message = "Used placeholder as LLMManager was not available.";
      } else {
        // Proceed with LLM-based generation
        const systemPrompt = `You are a specialized code generation assistant.
Your sole task is to write ${language ? language + ' ' : ''}code based on the following description.
You MUST output only the raw code, without any surrounding explanations, comments that are not part of the code itself, or markdown formatting (e.g., no \`\`\`${language || ''} \`\`\` backticks).

Description:
${codeDescription}

${language ? language.toUpperCase() + ' ' : ''}CODE:`;
        try {
          const model = this.llmManager.getModel(); // Assumes getModel() provides a suitable model instance
          if (!model) {
            throw new Error("LLM model not available from LLMManager.");
          }
          console.log(`CodeAgent: Requesting LLM to generate code for description: "${codeDescription}" for file ${filePath}`);
          const llmResponse = await generateText({
            model: model,
            prompt: systemPrompt,
          });
          let generatedCode = llmResponse.text.trim();

          // Optional: Add heuristics to remove backticks if LLM doesn't follow instructions strictly
          const langBacktick = `\`\`\`${language || ''}`;
          if (generatedCode.startsWith(langBacktick)) {
              generatedCode = generatedCode.substring(langBacktick.length).trimStart();
              if (generatedCode.endsWith('```')) {
                  generatedCode = generatedCode.substring(0, generatedCode.length - 3).trimEnd();
              }
          } else if (generatedCode.startsWith('```')) {
               generatedCode = generatedCode.substring(3).trimStart();
               if (generatedCode.endsWith('```')) {
                  generatedCode = generatedCode.substring(0, generatedCode.length - 3).trimEnd();
              }
          }

          actionString = `<boltAction type="file" filePath="${this.escapeXml(filePath)}" content="${this.escapeXml(generatedCode)}"></boltAction>`;
          message = "Code generated by LLM.";
          console.log(`CodeAgent: LLM generated code for '${filePath}'. Length: ${generatedCode.length}`);

        } catch (error: any) {
          console.error(`CodeAgent: Error during LLM code generation for "${filePath}":`, error);
          const placeholderCode = `// TODO: LLM generation failed: ${this.escapeXml(error.message)}. Implement code for: ${this.escapeXml(codeDescription)}
// Language: ${language || 'unknown'}`;
          actionString = `<boltAction type="file" filePath="${this.escapeXml(filePath)}" content="${this.escapeXml(placeholderCode)}"></boltAction>`;
          message = `LLM generation failed: ${error.message}. Used placeholder.`;
        }
      }
    } else {
      console.error("CodeAgent: Missing codeContent or codeDescription in task input.");
      return { error: "Missing codeContent or codeDescription for CodeAgent", status: "failure" };
    }
    
    return { actionString, status: "success", message };
  }

  /**
   * Escapes XML special characters for content and attributes.
   * @param str The string to escape.
   * @returns The escaped string.
   */
  private escapeXml(str: string): string {
    if (typeof str !== 'string') return '';
    return str.replace(/[<>&"']/g, (match) => {
      switch (match) {
        case '<': return '&lt;';
        case '>': return '&gt;';
        case '&': return '&amp;';
        case '"': return '&quot;';
        case "'": return '&apos;';
        default: return match;
      }
    });
  }
}
